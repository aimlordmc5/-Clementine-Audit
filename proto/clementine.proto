syntax = "proto3";

package clementine;

service ClementineOperator {
  rpc GetParams(Empty) returns (OperatorParams) {}

  rpc DepositSign(DepositParams) returns (stream OperatorBurnSig) {}
}

service ClementineVerifier {
    rpc SetVerifiers(Verifiers) returns (Empty) {}
    rpc SetOperator(OperatorParams) returns (Empty) {}
    rpc DepositNonceGen(Empty) returns (stream PubNonce) {}
    rpc DepositSign(stream VerifierDepositSignParams) returns (stream PartialSig) {}
    rpc DepositFinalize(stream VerifierDepositFinalizeParams) returns (PartialSig) {}
}

service ClementineWatchtower {
}

service ClementineAggregator {
    // This will call, DepositNonceGen for every verifier,
    // then it will aggregate one by one and then send it to DepositSign,
    // then it will aggregate the partial sigs and send it to DepositFinalize,
    // this will also call the operator to get their signatures and send it to DepositFinalize
    // then it will collect the partial sigs and create the move tx.
    rpc NewDeposit(DepositParams) returns (RawSignedMoveTx) {}
}

message RawSignedMoveTx {
    bytes raw_tx = 1;
}

message Verifiers {
    repeated string verifier_public_keys = 1;
}

// Musig2 Public Nonces of every verifier
message AggreateNoncesParams {
    repeated PubNonce pub_nonces = 1;
}

// Musig2 Partial Signatures of every verifier
message AggregatePartialSigParams {
    repeated PartialSig partial_sigs = 1;
}

message VerifierDepositSignParams {
    oneof params {
        DepositParams DepositParams = 1;
        AggNonce agg_nonce = 2;
    }
 }

message VerifierDepositFinalizeParams {
    oneof params {
        DepositParams DepositParams = 1;
        SchnorrSig schnorr_sig = 2;
    }
}

message Outpoint {
  bytes txid = 1;
  uint32 vout = 2;
}

message DepositParams {
    Outpoint deposit_outpoint = 1;
    bytes evm_address = 2;
    string recovery_taproot_address = 3;
    uint64 user_takes_after = 4;
}

message OperatorBurnSig {
    bytes schnorr_sig = 1;
}

message OperatorBurnSigs {
    repeated bytes sigs = 1;
}


message OperatorDetails {
    uint32 operator_id = 1;
    Outpoint initial_time_tx_outpoint = 2;
    string xonly_pk = 3;
    string wallet_reimburse_address = 4;
}

message OperatorParams {
    OperatorDetails operator_details = 1;
    repeated bytes winternitz_pubkeys = 5;
    repeated bytes preimages = 6;
    repeated SchnorrSig timeout_tx_sigs = 7;
}


message PubNonce {
    bytes pub_nonce = 1;
}

message AggNonce {
    bytes agg_nonce = 1;
}

message PartialSig {
    bytes partial_sig = 1;
}

message SchnorrSig {
    bytes schnorr_sig = 1;
}


message WinternitzPubkey {
    uint32 d = 1;
    uint32 n0 = 2;
    repeated bytes digit_pubkey = 3;
}


// Watchtowers only needs the operator_id, initial_time_tx_outpoint and the xonly_pk.
// They will calculate all time_txs
message WathctowerSetOperatorParams {
    OperatorDetails operator_details = 1;
}

message WatchtowerGetPubkeysPerOperatorParams {
    uint32 operator_id = 1;
}

// Their winternitz pubkeys 
message WatchtowerGetPubkeysPerOperatorResponse {
    // This is the order of the watchtower, starting from 0, vouts reserved for this watchtower is 2*wathctower_id and 2*wathctower_id + 1.
    uint32 wathctower_id = 1;
    // The winternitz pubkeys to start a challenge
    repeated WinternitzPubkey winternitz_pubkeys = 2;
}

// Verifier set operator params
message VerifierSetOperatorParams {
    OperatorDetails operator_details = 1;
    repeated WinternitzPubkey winternitz_pubkeys = 2;
    repeated bytes preimages = 3;
    repeated SchnorrSig timeout_tx_sigs = 4;
}




message Empty {}